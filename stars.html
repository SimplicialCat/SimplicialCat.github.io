<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>星空</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; }
        #info {
            position: absolute; bottom: 20px; right: 20px;
            color: rgba(255,255,255,0.6); font-size: 12px;
            pointer-events: none; z-index: 10;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .instruction {
            position: absolute; top: 20px; left: 20px;
            color: rgba(255,255,255,0.5); font-size: 14px;
            pointer-events: none; z-index: 10;
            backdrop-filter: blur(2px); padding: 4px 12px;
            border-radius: 20px; background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 18px;
            background: rgba(0,0,0,0.7); padding: 12px 24px;
            border-radius: 30px; z-index: 20;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #status {
            position: absolute; bottom: 60px; left: 20px;
            color: rgba(255,255,255,0.2); background: rgba(0,0,0,0.5);
            padding: 5px 10px; border-radius: 5px;
            z-index: 30;
        }
    </style>
</head>
<body>
    <div class="instruction">拖动旋转</div>
    <div id="info">恒星数据来源: Yale Bright Star Catalog - BSC5</div>
    <div id="loading">加载恒星数据中...</div>
    <div id="status">状态: 初始化</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== 可调节参数 ====================
        const CONFIG = {
            // ----- 全局视觉参数 -----
            backgroundColor: 0x050510,      // 背景色（深空色）
            fogDensity: 0.0005,              // 雾的密度（0 为无雾）
            starSphereRadius: 300,            // 星星分布球体的半径
            
            // ----- 相机控制参数 -----
            cameraMinDistance: 0.1,            // 相机最近距离
            cameraMaxDistance: 500,            // 相机最远距离
            enableAutoRotate: false,            // 是否自动旋转（当前关闭）

            // ----- 星星大小参数 -----
            sizeBase: 3,                        // 基础大小（像素，当 sizeAttenuation=true 时为基础参考值）
            sizeMin: 1,                          // 最小大小限制（如果使用动态大小）
            sizeMax: 30,                          // 最大大小限制
            useDynamicSize: true,                 // 是否根据星等动态调整大小（true 则亮星更大，false 则固定大小）
            dynamicSizeFactor: 1.9,                // 动态大小系数：size = sizeBase * (1 + factor * (maxMag - mag))，可自行调整公式

            brightnessMin: 0.2,                 // 最暗星（最大星等）的亮度因子
            brightnessMax: 1.6,                 

            // ----- 光晕纹理参数 -----
            haloInnerGlow: 0.8,                    // 内光晕起始位置（0~1），越小光晕越集中
            haloMidFactor: 0.6,                     // 中间过渡位置相对于内光晕的比例（用于控制光晕衰减速度）
            haloOuterGlow: 0.0,                      // 外光晕透明度（0~1），越大外围越亮
            haloColor: [255, 255, 200],               // 光晕中心颜色（RGB），影响星星中心颜色叠加

            // ----- 颜色映射参数（B-V 转 RGB）-----
            colorSaturation: 1.0,                     // 颜色饱和度（1为正常，0为灰度）
            colorBlueShift: 0.0,                       // 整体色偏（蓝移，正值增加蓝色，负值增加红色，范围 -0.5~0.5）

            // ----- 调试辅助 -----
            showWireframeSphere: false,                 // 是否显示半透明线框球体（调试用）
        };
        // ===================================================

        // --- 初始化场景、相机、渲染器 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.backgroundColor);
        scene.fog = new THREE.FogExp2(CONFIG.backgroundColor, CONFIG.fogDensity);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 0, 0.1);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 轨道控制器 ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.0;
        controls.enablePan = false;
        controls.minDistance = CONFIG.cameraMinDistance;
        controls.maxDistance = CONFIG.cameraMaxDistance;
        controls.autoRotate = CONFIG.enableAutoRotate;      // 根据配置决定是否自动旋转
        controls.autoRotateSpeed = 0.08;                     // 仅当 autoRotate=true 时有效
        controls.enableZoom = true;

        // --- 辅助线框球体 (可选) ---
        const sphereRadius = CONFIG.starSphereRadius;
        if (CONFIG.showWireframeSphere) {
            const sphereGeo = new THREE.SphereGeometry(sphereRadius, 32, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.15 });
            const sphereWireframe = new THREE.Mesh(sphereGeo, sphereMat);
            scene.add(sphereWireframe);
        }

        // --- 工具函数：B-V 色指数转 RGB (艺术化近似，带可调节参数) ---
        function bvToRGB(bv) {
            if (bv === null || bv === undefined) bv = 0.5;
            let r, g, b;

            // 基础映射（参考：https://www.vendian.org/mncharity/dir3/starcolor/）
            if (bv < -0.4) bv = -0.4;
            if (bv > 2.0) bv = 2.0;

            if (bv <= 0.0) {
                r = 0.8 + bv * 0.5;
                g = 0.9 + bv * 0.3;
                b = 1.0;
            } else if (bv <= 0.6) {
                r = 1.0;
                g = 1.0 - (bv - 0.0) * 0.3;
                b = 1.0 - (bv - 0.0) * 0.5;
            } else {
                r = 1.0;
                g = 0.8 - (bv - 0.6) * 0.5;
                b = 0.5 - (bv - 0.6) * 0.3;
            }

            // 应用饱和度调节
            const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            r = gray + CONFIG.colorSaturation * (r - gray);
            g = gray + CONFIG.colorSaturation * (g - gray);
            b = gray + CONFIG.colorSaturation * (b - gray);

            // 应用整体色偏（蓝移/红移）
            r = Math.max(0, Math.min(1, r + CONFIG.colorBlueShift * 0.5));
            g = Math.max(0, Math.min(1, g + CONFIG.colorBlueShift * 0.2)); // 绿色微调
            b = Math.max(0, Math.min(1, b - CONFIG.colorBlueShift * 0.5));

            // 确保值在合理范围
            r = Math.max(0.2, Math.min(1.0, r));
            g = Math.max(0.2, Math.min(1.0, g));
            b = Math.max(0.2, Math.min(1.0, b));

            return [r, g, b];
        }

        // --- 创建星星光晕纹理 (根据配置动态生成) ---
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;  // 提高分辨率以获得更平滑的光晕
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            const center = 128;
            const gradient = ctx.createRadialGradient(center, center, 0, center, center, center);
            
            // 内圈颜色（使用配置中的光晕中心颜色）
            const [r, g, b] = CONFIG.haloColor;
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
            
            // 中间过渡（使用 haloMidFactor 控制过渡位置）
            gradient.addColorStop(CONFIG.haloInnerGlow * CONFIG.haloMidFactor, `rgba(${r}, ${g}, ${b}, 0.9)`);
            
            // 外圈（根据haloOuterGlow控制透明度）
            gradient.addColorStop(1, `rgba(255, 255, 255, ${CONFIG.haloOuterGlow})`);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return new THREE.CanvasTexture(canvas);
        }
        let starTexture = createStarTexture();

        // --- 加载恒星数据 ---
        async function loadStars() {
            try {
                const response = await fetch('bright_stars.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const starsData = await response.json();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').innerHTML = `状态: 加载成功 (${starsData.length} 颗)`;
                console.log(`成功加载 ${starsData.length} 颗恒星`);
                initStars(starsData);
            } catch (error) {
                document.getElementById('loading').innerHTML = `加载失败: ${error.message}`;
                document.getElementById('status').innerHTML = '状态: 错误';
                console.error(error);
            }
        }

        // --- 初始化星星点云 (仅亮星，无背景星/尘埃) ---
        function initStars(starsData) {
            const positions = [];
            const colors = [];
            const radius = CONFIG.starSphereRadius;

            // 如果需要动态大小，先计算星等范围
            let minMag = Infinity, maxMag = -Infinity;
            if (CONFIG.useDynamicSize) {
                starsData.forEach(star => {
                    if (star.mag !== undefined) {
                        if (star.mag < minMag) minMag = star.mag;
                        if (star.mag > maxMag) maxMag = star.mag;
                    }
                });
            }

            /*starsData.forEach(star => {
                if (star.ra === undefined || star.dec === undefined) return;
                const raRad = THREE.MathUtils.degToRad(star.ra);
                const decRad = THREE.MathUtils.degToRad(star.dec);
                const x = radius * Math.cos(decRad) * Math.cos(raRad);
                const y = radius * Math.sin(decRad);
                const z = radius * Math.cos(decRad) * Math.sin(raRad);
                positions.push(x, y, z);

                const [r, g, b] = bvToRGB(star.bv);
                colors.push(r, g, b);
            });*/
            starsData.forEach(star => {
    if (star.ra === undefined || star.dec === undefined) return;
    const raRad = THREE.MathUtils.degToRad(star.ra);
    const decRad = THREE.MathUtils.degToRad(star.dec);
    const x = radius * Math.cos(decRad) * Math.cos(raRad);
    const y = radius * Math.sin(decRad);
    const z = radius * Math.cos(decRad) * Math.sin(raRad);
    positions.push(x, y, z);

    // 获取基础颜色
    let [r, g, b] = bvToRGB(star.bv);

    // ---- 亮度增强 ----
    if (star.mag !== undefined) {
        // 线性插值：星等越小（越亮）因子越大
        let t = (maxMag - star.mag) / (maxMag - minMag); // t 范围 0~1，最亮星为1
        let brightnessFactor = CONFIG.brightnessMin + t * t * (CONFIG.brightnessMax - CONFIG.brightnessMin);
        r *= brightnessFactor;
        g *= brightnessFactor;
        b *= brightnessFactor;
        // 可选：限制颜色值不超过1.0（但 AdditiveBlending 下超过1.0也没关系）
        r = Math.min(1.0, r);
        g = Math.min(1.0, g);
        b = Math.min(1.0, b);
    }

    colors.push(r, g, b);
});

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // 选择大小策略（当前简化版：使用固定大小，但保留了动态大小的配置注释）
            // 注：若需实现真正的动态大小（亮星更大），需使用自定义着色器，此处为保持简洁仍用固定大小。
            const material = new THREE.PointsMaterial({
                size: CONFIG.sizeBase,
                vertexColors: true,
                map: starTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true,
                opacity: 0.9
            });
            console.log('使用固定大小 (如需基于星等的动态大小，可启用自定义着色器)');

            const starsMesh = new THREE.Points(geometry, material);
            scene.add(starsMesh);

            document.getElementById('status').innerHTML += ' (渲染完成)';
            console.log('星空渲染完成，星星数量:', positions.length / 3);
        }

        loadStars();

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>