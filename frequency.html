<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>频率比</title>
    <style>
        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        body {
            background: #FAFBFC;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            margin: 0;
            padding: 16px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        .main-canvas,
        .waveform-canvas {
            max-width: 100%;
            height: auto;
            display: block;
        }
        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            color: #253055;
            font-weight: 500;
        }
        .ratio-badge {
            background: #3a3c4b;
            padding: 6px 18px;
            border-radius: 40px;
            color: #b9bae6;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.5px;
        }
        /* 新增播放按钮样式 */
        .play-toggle {
            background: #caccfb;
            border: none;
            color: #ffffffdd;
            font-size: 1.6rem;
            line-height: 1;
            width: 48px;
            height: 48px;
            border-radius: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: background 0.15s;
            padding: 0;
            outline: none;
            touch-action: manipulation;
        }
        .play-toggle:active {
            background: #5f4bb6;
            transform: scale(0.96);
        }
        .hint {
            color: #7f8196;
            font-size: 0.85rem;
            margin-top: 8px;
            text-align: center;
        }
        .waveform-label {
            display: flex;
            justify-content: space-between;
            margin: 4px 10px 0;
            color: #a0a3c0;
            font-size: 0.8rem;
        }
        .label-left {
            color: #253055;
        }
        .label-right {
            color: #253055;
        }
    </style>
</head>
<body>
<div class="container">
    <canvas id="circleCanvas" class="main-canvas" width="800" height="800"></canvas>
    <div class="info-panel">
        <span class="freq-value" id="ratioDisplay">频率比 1 : 1.000</span>
        <!-- 独立播放按钮，取代圆心内的图标 -->
        <button id="playToggle" class="play-toggle" aria-label="播放/暂停">▶</button>
    </div>
    <canvas id="waveformCanvas" class="waveform-canvas" width="800" height="200"></canvas>
</div>
<script>
    (function() {
        // ---------- 画布与几何 ----------
        const canvas = document.getElementById('circleCanvas');
        const ctx = canvas.getContext('2d');
        const w = 800, h = 800;
        const centerX = 400, centerY = 400;
        const bigR = 240;
        const innerCircleR = bigR - 40;
        const outerCircleR = bigR + 45;
        const buttonR = 44;          // 圆心纯色圆盘半径（不再可点击）

        // 固定起点：12点钟方向 (角度 -PI/2)
        const START_ANGLE = -Math.PI / 2;

        // 可变的终点参数：扇形占比 x (0~1)
        let x = 0.585;                // 默认值（可自行调整）

        // ---------- 音频相关 ----------
        let audioCtx = null;
        let osc1 = null, osc2 = null;
        let gainNodeC = null;         // 中央C的增益
        let gainNodeSecond = null;     // 第二音的增益
        let isPlaying = false;

        const CENTRAL_C_FREQ = 261.6;

        // ---------- 波形画布 ----------
        const waveCanvas = document.getElementById('waveformCanvas');
        const wCtx = waveCanvas.getContext('2d');
        const waveWidth = 800, waveHeight = 200;

        // ---------- 交互状态 ----------
        let isDragging = false;
        let dragListenersAttached = false;

        // ---------- DOM 元素 ----------
        const ratioDisplay = document.getElementById('ratioDisplay');
        const playToggle = document.getElementById('playToggle');  // 新增按钮

        // ---------- 刻度定义（完全保留） ----------
        const INNER_TICK_LEN = 15;
        const RATIONAL_TICKS = [
            { ratio: 9/8,  label: '9/8' },
            { ratio: 6/5,  label: '6/5' },
            { ratio: 5/4,  label: '5/4' },
            { ratio: 4/3,  label: '4/3' },
            { ratio: 7/5,  label: '7/5' },
            { ratio: 3/2,  label: '3/2' },
            { ratio: 8/5,  label: '8/5' },
            { ratio: 5/3,  label: '5/3' },
            { ratio: 15/8, label: '15/8' },
            { ratio: 2/1,  label: '2/1' }
        ];
        const OUTER_INNER_TICK_LEN = 18;
        const INNER_CIRCLE_TICK_LEN_INWARD = 15;
        const INNER_CIRCLE_COLOR = '#b87ad0';
        const NOTE_NAMES = [
            { index: 0, name: 'C' },
            { index: 2, name: 'D' },
            { index: 4, name: 'E' },
            { index: 5, name: 'F' },
            { index: 7, name: 'G' },
            { index: 9, name: 'A' },
            { index: 11, name: 'B' }
        ];

        // ---------- 辅助函数 ----------
        function computeRatioFromMouse(mx, my) {
            const dx = mx - centerX;
            const dy = my - centerY;
            let rawAngle = Math.atan2(dy, dx);
            let diff = (rawAngle - START_ANGLE + 2 * Math.PI) % (2 * Math.PI);
            return diff / (2 * Math.PI);
        }

        function getEndAngleFromX(ratio) {
            return START_ANGLE + ratio * 2 * Math.PI;
        }

        // ---------- 更新显示文字及音频频率 ----------
        function updateStatsAndAudio() {
            const ratio = Math.pow(2, x);
            ratioDisplay.innerHTML = `频率比 : 2<sup>${x.toFixed(3)}</sup> = ${ratio.toFixed(3)}`;

            if (isPlaying && osc2 && audioCtx) {
                try {
                    const secondFreq = CENTRAL_C_FREQ * ratio;
                    osc2.frequency.setValueAtTime(secondFreq, audioCtx.currentTime);
                } catch (e) {}
            }
        }

        // ---------- 绘制主画布（圆心改为纯色圆盘，无图标）----------
        function drawCanvas() {
            ctx.clearRect(0, 0, w, h);

            // ----- 绘制透明扇形 -----
            const endAngle = getEndAngleFromX(x);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, outerCircleR, START_ANGLE, endAngle);
            ctx.closePath();
            ctx.fillStyle = 'rgba(20,20,255,0.05)';
            ctx.shadowBlur = 12;
            ctx.shadowColor = '#ffac6f40';
            ctx.fill();
            ctx.shadowBlur = 0;

            // ----- 大圆 (外边框) 实线 -----
            ctx.beginPath();
            ctx.arc(centerX, centerY, bigR, 0, 2 * Math.PI);
            ctx.strokeStyle = '#6d6f8f';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.stroke();

            // ----- 内圈 (19平均律参考圆) 和外圈 (有理数参考圆) 实线 -----
            ctx.beginPath();
            ctx.arc(centerX, centerY, innerCircleR, 0, 2 * Math.PI);
            ctx.strokeStyle = '#4d4f6e';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(centerX, centerY, outerCircleR, 0, 2 * Math.PI);
            ctx.strokeStyle = '#6e5f4d';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // ===== 1. 12平均律向内刻度线 =====
            ctx.lineWidth = 1.8;
            ctx.strokeStyle = '#7c9fd0';
            for (let k = 1; k <= 11; k++) {
                const tickRatio = k / 12;
                const angle = START_ANGLE + tickRatio * 2 * Math.PI;
                const startX = centerX + bigR * Math.cos(angle);
                const startY = centerY + bigR * Math.sin(angle);
                const endX = centerX + (bigR - INNER_TICK_LEN) * Math.cos(angle);
                const endY = centerY + (bigR - INNER_TICK_LEN) * Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // ===== 2. 19平均律刻度线 (从内圈向内) =====
            ctx.lineWidth = 1.8;
            ctx.strokeStyle = INNER_CIRCLE_COLOR;
            for (let k = 1; k <= 18; k++) {
                const tickRatio = k / 19;
                const angle = START_ANGLE + tickRatio * 2 * Math.PI;
                const startX = centerX + innerCircleR * Math.cos(angle);
                const startY = centerY + innerCircleR * Math.sin(angle);
                const endX = centerX + (innerCircleR - INNER_CIRCLE_TICK_LEN_INWARD) * Math.cos(angle);
                const endY = centerY + (innerCircleR - INNER_CIRCLE_TICK_LEN_INWARD) * Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // ===== 3. 有理数向外刻度线 (从外圈向内) =====
            ctx.lineWidth = 2.0;
            ctx.strokeStyle = '#253055';
            ctx.font = 'bold 14px "Segoe UI", "JetBrains Mono", monospace';
            ctx.fillStyle = '#253055';
            ctx.shadowBlur = 1;
            ctx.shadowColor = '#25305580';
            RATIONAL_TICKS.forEach(item => {
                const ratio = item.ratio;
                const xTick = Math.log2(ratio);
                if (xTick < 0 || xTick > 1) return;

                const angle = START_ANGLE + xTick * 2 * Math.PI;
                const startX = centerX + outerCircleR * Math.cos(angle);
                const startY = centerY + outerCircleR * Math.sin(angle);
                const endX = centerX + (outerCircleR - OUTER_INNER_TICK_LEN) * Math.cos(angle);
                const endY = centerY + (outerCircleR - OUTER_INNER_TICK_LEN) * Math.sin(angle);

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                const labelX = centerX + (outerCircleR + 16) * Math.cos(angle);
                const labelY = centerY + (outerCircleR + 16) * Math.sin(angle);
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                if (cosA > 0.15) ctx.textAlign = 'left';
                else if (cosA < -0.15) ctx.textAlign = 'right';
                else ctx.textAlign = 'center';
                if (sinA > 0.2) ctx.textBaseline = 'top';
                else if (sinA < -0.2) ctx.textBaseline = 'bottom';
                else ctx.textBaseline = 'middle';

                ctx.fillText(item.label, labelX, labelY);
            });
            ctx.shadowBlur = 0;

            // ===== 4. 12平均律音名标注 =====
            ctx.font = 'bold 16px "Segoe UI", "Arial", sans-serif';
            ctx.fillStyle = '#465BAF';
            ctx.shadowBlur = 1;
            ctx.shadowColor = '#253055';
            NOTE_NAMES.forEach(note => {
                const tickRatio = note.index / 12;
                const angle = START_ANGLE + tickRatio * 2 * Math.PI;
                const textRadius = bigR - INNER_TICK_LEN - 18;
                const textX = centerX + textRadius * Math.cos(angle);
                const textY = centerY + textRadius * Math.sin(angle);
                const cosA = Math.cos(angle);
                const sinA = Math.sin(angle);
                if (cosA > 0.1) ctx.textAlign = 'left';
                else if (cosA < -0.1) ctx.textAlign = 'right';
                else ctx.textAlign = 'center';
                if (sinA > 0.1) ctx.textBaseline = 'top';
                else if (sinA < -0.1) ctx.textBaseline = 'bottom';
                else ctx.textBaseline = 'middle';
                ctx.fillText(note.name, textX, textY);
            });
            ctx.shadowBlur = 0;

            // ----- 指针 (从圆心到最外圈) -----
            const endX = centerX + outerCircleR * Math.cos(endAngle);
            const endY = centerY + outerCircleR * Math.sin(endAngle);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#253055cc';
            ctx.lineWidth = 2.5;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#25305560';
            ctx.stroke();

            // ----- 圆心纯色圆盘（固定颜色，无图标）-----
            /*ctx.beginPath();
            ctx.arc(centerX, centerY, buttonR, 0, 2 * Math.PI);
            ctx.fillStyle = '#42435a';        // 纯色，不再随播放状态变化
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00000060';
            ctx.fill();
            ctx.shadowBlur = 0;*/
            // 不再绘制任何播放/暂停图标
        }

        // ---------- 绘制实时波形 (与原代码完全相同) ----------
        function drawWaveform() {
            wCtx.clearRect(0, 0, waveWidth, waveHeight);

            const f1 = CENTRAL_C_FREQ;
            const f2 = CENTRAL_C_FREQ * Math.pow(2, x);
            const duration = 80 / f1;
            const steps = waveWidth * 4;
            const timeStep = duration / steps;
            const centerY = waveHeight / 2;
            const amplitude = 40;

            // 零轴参考线
            wCtx.strokeStyle = '#3e4055';
            wCtx.lineWidth = 0.8;
            wCtx.beginPath();
            wCtx.moveTo(0, centerY);
            wCtx.lineTo(waveWidth, centerY);
            wCtx.stroke();

            // 中央C (蓝色)
            wCtx.beginPath();
            wCtx.strokeStyle = '#465BAF';
            wCtx.lineWidth = 2.2;
            for (let i = 0; i < steps; i++) {
                const t = i * timeStep;
                const phase = 2 * Math.PI * f1 * t;
                const y = centerY + Math.sin(phase) * amplitude;
                if (i === 0) wCtx.moveTo(i, y);
                else wCtx.lineTo(i, y);
            }
            wCtx.stroke();

            // 第二音 (深色)
            wCtx.beginPath();
            wCtx.strokeStyle = '#253055';
            wCtx.lineWidth = 1.8;
            for (let i = 0; i < steps; i++) {
                const t = i * timeStep;
                const phase = 2 * Math.PI * f2 * t;
                const y = centerY + Math.sin(phase) * amplitude;
                if (i === 0) wCtx.moveTo(i, y);
                else wCtx.lineTo(i, y);
            }
            wCtx.stroke();

            wCtx.font = '12px "Segoe UI", monospace';
            wCtx.fillStyle = '#465BAF';
            wCtx.fillText('261.6 Hz', 10, 20);
            wCtx.fillStyle = '#253055';
            wCtx.fillText(`${f2.toFixed(1)} Hz`, 10, 40);
        }

        // ---------- 音频控制（适配移动端）----------
        async function togglePlay() {
            if (window._toggling) return;
            window._toggling = true;

            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    gainNodeC = audioCtx.createGain();
                    gainNodeSecond = audioCtx.createGain();
                    gainNodeC.gain.value = 0.24;
                    gainNodeSecond.gain.value = 0.12;
                    gainNodeC.connect(audioCtx.destination);
                    gainNodeSecond.connect(audioCtx.destination);
                }

                if (isPlaying) {
                    // 停止
                    gainNodeC.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNodeSecond.gain.setValueAtTime(0, audioCtx.currentTime);
                    [osc1, osc2].forEach(osc => {
                        if (osc) {
                            try { osc.stop(); } catch (e) {}
                            try { osc.disconnect(); } catch (e) {}
                        }
                    });
                    osc1 = osc2 = null;
                    isPlaying = false;
                    if (audioCtx.state === 'running') {
                        await audioCtx.suspend();
                    }
                    playToggle.textContent = '▶';   // 更新按钮
                } else {
                    // 启动（先创建振荡器再恢复上下文，确保移动端发声）
                    const secondFreq = CENTRAL_C_FREQ * Math.pow(2, x);

                    osc1 = audioCtx.createOscillator();
                    osc1.type = 'sine';
                    osc1.frequency.value = CENTRAL_C_FREQ;
                    osc1.connect(gainNodeC);

                    osc2 = audioCtx.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.value = secondFreq;
                    osc2.connect(gainNodeSecond);

                    // 在上下文未恢复时 start 是安全的
                    osc1.start();
                    osc2.start();

                    gainNodeC.gain.setValueAtTime(0.24, audioCtx.currentTime);
                    gainNodeSecond.gain.setValueAtTime(0.12, audioCtx.currentTime);

                    if (audioCtx.state === 'suspended') {
                        await audioCtx.resume();
                    } else if (audioCtx.state === 'closed') {
                        // 极少情况，重新创建（简化处理，重新赋值）
                        audioCtx = new AudioContext();
                        // 重新连接（略，实际很少遇到）
                    }

                    isPlaying = true;
                    playToggle.textContent = '⏸';   // 更新按钮
                }

                drawCanvas();            // 圆心颜色不再变化，但保留重绘
                updateStatsAndAudio();
            } finally {
                window._toggling = false;
            }
        }

        // ---------- 鼠标/触摸交互（圆心区域变为死区，不再响应点击）----------
        function handleDragStart(e) {
            e.preventDefault();

            const { mx, my } = getCanvasCoords(e);
            if (mx === undefined) return;

            const distToCenter = Math.hypot(mx - centerX, my - centerY);

            // 圆心纯色圆盘区域：不启动拖动，也不触发任何操作（死区）
            if (distToCenter <= buttonR) {
                return;
            }

            // 其余位置启动拖动
            isDragging = true;
            const newX = computeRatioFromMouse(mx, my);
            x = Math.min(1, Math.max(0, newX));
            drawCanvas();
            updateStatsAndAudio();
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();

            const { mx, my } = getCanvasCoords(e);
            if (mx === undefined) return;

            const newX = computeRatioFromMouse(mx, my);
            x = Math.min(1, Math.max(0, newX));
            drawCanvas();
            updateStatsAndAudio();
        }

        function handleDragEnd(e) {
            if (isDragging) {
                isDragging = false;
                e.preventDefault();
                drawCanvas();
            }
        }

        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;

            if (e.touches) {
                if (e.touches.length === 0) return { mx: undefined, my: undefined };
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const offsetX = (clientX - rect.left) * scaleX;
            const offsetY = (clientY - rect.top) * scaleY;

            const mx = Math.min(w, Math.max(0, offsetX));
            const my = Math.min(h, Math.max(0, offsetY));
            return { mx, my };
        }

        function attachEvents() {
            if (dragListenersAttached) return;

            canvas.addEventListener('mousedown', handleDragStart);
            canvas.addEventListener('mousemove', handleDragMove);
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);

            canvas.addEventListener('touchstart', handleDragStart, { passive: false });
            canvas.addEventListener('touchmove', handleDragMove, { passive: false });
            canvas.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('touchcancel', handleDragEnd);

            dragListenersAttached = true;
        }

        // 动画循环 (波形静止，但需要持续重绘以响应频率变化)
        function animateWaveform() {
            drawWaveform();
            requestAnimationFrame(animateWaveform);
        }

        // 初始化
        function init() {
            // 设置默认 x（与原代码一致）
            x = 0.585;
            drawCanvas();
            updateStatsAndAudio();

            // 绑定独立播放按钮
            playToggle.addEventListener('click', togglePlay);

            attachEvents();

            window.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    drawCanvas();
                }
            });

            animateWaveform();
        }

        init();
    })();
</script>
</body>
</html>