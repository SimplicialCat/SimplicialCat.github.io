<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>和弦进行</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background:
                radial-gradient(
                circle at 87% 13%,
              rgba(70, 91, 207, 0.03) 0%,
                transparent 70%
                ),
                #FAFBFC;
            color: #253055;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 12rem 1rem;
        }
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }
        .title {
            text-align: center;
        }
        .input-field {
            flex: 1 1 200px;
            padding: 0.7rem 0.5rem;
            font-size: 1rem;
            border: none;
            border-bottom: 1px solid #6AC6E8;
            background: transparent;
            outline: none;
        }
        .input-field:focus { border-bottom-color: #253055; }
        .input-field::placeholder { color: #6AC6E8; font-weight: 300; }

        .btn {
            padding: 0.5rem 0.9rem;
            font-size: 1.5rem;
            border: none;
            background: transparent;
            color: #465BAF;
            cursor: pointer;
            transition: 0.1s;
            border-radius: 0;
        }
/* ---------- 金色渐变符号：播放键 & 停止键 ---------- */
:root {
    --gold-dark: #BD9368;
    --gold-light: #DDB368;
    --gold-ultra-light: #FDF388;
}

/* 播放键 & 停止键 共用基础渐变 */
.btn-play,
.btn-stop {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    
    /* 渐变文字核心 */
    background: linear-gradient(
        150deg,
        var(--gold-ultra-light) 20%,
        var(--gold-light) 60%,
        var(--gold-dark) 100%
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    
    /* 彻底去除背景色/边框 */
    background-color: transparent;
    border: none;
    
    /* 柔和阴影（仅作用于文字） */
    filter: drop-shadow(0 1px 2px rgba(120, 80, 40, 0.2));
    
    /* 过渡与变换基准 */
    transition: all 0.15s ease;
    transform: scale(1);
}

/* ----- 焦点状态（无鼠标悬停时）----- */
.btn-play:focus,
.btn-stop:focus {
    background: linear-gradient(
        150deg,
        var(--gold-ultra-light) 20%,
        var(--gold-light) 60%,
        var(--gold-dark) 100%
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-color: transparent;
    transform: scale(1);               /* 保持原始大小 */
    filter: drop-shadow(0 1px 2px rgba(120, 80, 40, 0.2));
    outline: none;                    /* 移除默认焦点环 */
}

/* ----- 悬停状态（仅在支持hover的设备，且会覆盖焦点样式）----- */
@media (hover: hover) {
    .btn-play:hover,
    .btn-stop:hover {
        background: linear-gradient(
            150deg,
            #FFF9C4 20%,
            #FFD97E 60%,
            #E6B86B 100%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        background-color: transparent;  /* 覆盖全局 .btn:hover 的蓝色 */
        filter: drop-shadow(0 2px 5px rgba(180, 130, 70, 0.5));
        transform: scale(1.05);         /* 轻微放大 */
    }
}

/* ----- 激活（按下）状态 ----- */
.btn-play:active,
.btn-stop:active {
    background: linear-gradient(
        150deg,
        var(--gold-light) 20%,
        var(--gold-dark) 80%
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    background-color: transparent;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
    transform: scale(0.98);
}

        .preview {
            font-size: 0.75rem;
            color: rgba(0,0,0,0.45);
            word-break: break-all;
            padding: 0.3rem 0;
            border-top: 0.5px solid rgba(0,0,0,0.05);
            margin-top: 0.3rem;
            font-family: monospace;
        }
        .footer-hint {
            margin-top: 2.5rem;
            font-size: 0.8rem;
            color: rgba(0,0,0,0.5);
            text-align: center;
            line-height: 1.5;
            font-weight: 300;
        }
        hr {
            border: none;
            border-top: 0.5px solid rgba(0,0,0,0.05);
            margin: 0.8rem 0;
        }
        /* ---------- 和弦编码表编辑器：蓝色系 ---------- */
#chordTableInput {
    border: 1px solid #6AC6E8;        /* 与输入框下边框同色，保持完整边框 */
    background: white;                /* 纯白背景，干净明亮 */
    color: #253055;                  /* 深蓝色文字，与标题/焦点色一致 */
    border-radius: 4px;             /* 保留已有圆角 */
    padding: 0.8rem;               /* 保留已有内边距 */
    font-family: inherit;          /* 从内联保留（也可移至此处） */
    resize: vertical;             /* 保留 */
    transition: border-color 0.15s ease; /* 平滑过渡 */
}

#chordTableInput:focus {
    border-color: #253055;         /* 聚焦时变为深蓝，与 .input-field:focus 一致 */
    outline: none;                /* 移除默认轮廓，仅保留边框变色 */
    background: #fff;            /* 保持纯白 */
}

#chordTableInput::placeholder {
    color: #6AC6E8;             /* 占位符淡蓝色，与 .input-field::placeholder 一致 */
    font-weight: 300;           /* 细体 */
    opacity: 1;                /* 防止某些浏览器变灰 */
}
    </style>
</head>
<body>
    <div class="container">
        <div class="title">
            <h1>和弦进行</h1>
        </div>
        <!-- 第一行：和弦进行输入 + 编码表编辑按钮 -->
        <div class="row">
            <input type="text" id="chordProgInput" class="input-field" 
                   placeholder="C, G, Am, Em, F, G, C" autofocus>
        </div>

        <!-- 第二行：播放, 停止, 编码表, 持续时间 -->
        <div class="row" style="gap: 0.8rem;">
            <button id="playProgBtn" class="btn btn-play">▶</button>
            <button id="stopBtn" class="btn btn-stop">■</button>
            <button id="editTableBtn" class="btn" style="font-size:1rem;">✎ 编码表</button>
            持续
            <input type="number" id="durationInput" class="input-field" value="1.2" step="0.1" min="0.1" style="width: 80px; text-align: center; color:#465BAF; flex:none;" placeholder="1.2">
            秒
        </div>

        <!-- 编码表编辑区（默认隐藏） -->
        <textarea id="chordTableInput" 
                  style="width:100%; padding:0.8rem; font-size:0.9rem; border-radius:4px; background:#fafafa; display:none; resize:vertical; height: 10em; font-family: inherit; color:#253055"
                  placeholder="输入自定义和弦编码表（只写C调）&#10;例：&#10;C = C,E,G&#10;Cm = C,Eb,G&#10;C7 = C,E,G,Bb&#10;Cm7 = C,Eb,G,Bb&#10;Cmaj7 = C,E,G,B&#10;..."></textarea>

        <!-- 预览区：显示实际MIDI编号（调试/验证） -->
        <div id="preview" class="preview">—</div>

        <hr>
        <div class="footer-hint">
            • 输入和弦进行，以逗号分隔<br>
            • 编码表只写 C 开头的和弦（保留音符顺序）<br>
            • 支持斜杠和弦: X/Y 表示 X 和弦加入低音 Y<br>
            • 预览区显示实际MIDI编号
        </div>
    </div>

    <script>
        // ---------- 音符名称 ↔ 半音编号 ----------
        const NOTE_TO_PC = {
            'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11
        };
        const ACCIDENTAL_OFFSET = { 'b':-1, '#':1, '♭':-1, '♯':1 };

        function noteNameToPc(name) {
            if (!name) return null;
            let match = name.match(/^([A-G])([#b♭♯]*)$/);
            if (!match) return null;
            let root = NOTE_TO_PC[match[1]];
            let acc = match[2];
            for (let ch of acc) {
                root += ACCIDENTAL_OFFSET[ch] || 0;
            }
            return ((root % 12) + 12) % 12;
        }

        // ---------- 和弦模式存储 ----------
        // Map<string, { intervals: number[] }>  key = 类型名 (如 "", "m", "7", "9"等)
        let chordPatterns = new Map();

        // ---------- 默认编码表 ----------
        const DEFAULT_TABLE = `C = C,E,G
Cm = C,Eb,G
C7 = C,E,G,Bb
Cm7 = C,Eb,G,Bb
Cmaj7 = C,E,G,B
C6 = C,E,G,A
Cm6 = C,Eb,G,A
C9 = C,E,G,Bb,D
Cm9 = C,Eb,G,Bb,D
Cmaj9 = C,E,G,B,D
Cadd9 = C,E,G,D
Cmadd9 = C,Eb,G,D
C7b5 = C,E,Gb,Bb
Cm7b5 = C,Eb,Gb,Bb
Co7 = C,Eb,Gb,Bbb
Cdim = C,Eb,Gb
Cdim7 = C,Eb,Gb,A
Caug = C,E,G#
Cb5 = C,E,Gb
Csus4 = C,F,G
Csus2 = C,D,G
C11 = C,E,G,Bb,D,F
Cm11 = C,Eb,G,Bb,D,F
C13 = C,E,G,Bb,D,F,A
Cm13 = C,Eb,G,Bb,D,F,A
C69 = C,E,G,A,D
Cm69 = C,Eb,G,A,D
C7#9 = C,E,G,Bb,D#
Cmaj#11 = C,E,G,B,D,F#
Cm7b5(11) = C,Eb,Gb,Bb,F`;

        // ---------- 解析编码表 ----------
        function parseChordTable(tableStr) {
            const lines = tableStr.split(/\r?\n/);
            const patterns = new Map();
            for (let line of lines) {
                line = line.trim();
                if (line === '' || line.startsWith('//')) continue;
                let eqIdx = line.indexOf('=');
                if (eqIdx === -1) continue;
                let chordName = line.slice(0, eqIdx).trim();
                let notePart = line.slice(eqIdx + 1).trim();
                if (!chordName.startsWith('C')) continue;
                let type = chordName.slice(1); // 去掉开头的C
                let noteNames = notePart.split(',').map(s => s.trim()).filter(s => s.length > 0);
                let intervals = [];
                for (let n of noteNames) {
                    let pc = noteNameToPc(n);
                    if (pc !== null) {
                        let interval = (pc - 0 + 12) % 12;
                        intervals.push(interval);
                    }
                }
                if (intervals.length > 0) {
                    patterns.set(type, { intervals });
                }
            }
            return patterns;
        }

        // ---------- 根据根音和类型名获取音级序列 ----------
        function getChordPitches(rootPc, type) {
            let pattern = chordPatterns.get(type);
            if (!pattern) return null;
            return pattern.intervals.map(interval => (rootPc + interval) % 12);
        }

        // ---------- 解析完整和弦名称 ----------
        function parseChordName(fullName) {
            fullName = fullName.trim();
            let slashIdx = fullName.indexOf('/');
            let chordPart, bassName = null;
            if (slashIdx !== -1) {
                chordPart = fullName.slice(0, slashIdx).trim();
                bassName = fullName.slice(slashIdx + 1).trim();
            } else {
                chordPart = fullName;
            }
            let rootMatch = chordPart.match(/^([A-G][#b♭♯]*)/);
            if (!rootMatch) return null;
            let rootStr = rootMatch[1].trim();
            let rootPc = noteNameToPc(rootStr);
            if (rootPc === null) return null;
            let type = chordPart.slice(rootStr.length);
            // 常见记号归一化
            if (type === 'Δ') type = 'maj7';
            else if (type === 'ø') type = 'm7b5';
            else if (type === '-') type = 'm';
            else if (type === '+') type = 'aug';
            
            let pitches = getChordPitches(rootPc, type);
            if (!pitches) return null;

            let bassPc = null;
            if (bassName) {
                bassPc = noteNameToPc(bassName);
            }
            return { pitches, bassPc };
        }

        // ---------- 将音级序列转换为MIDI编号，最低音C4–C5 ----------
        function pitchesToMidi(pitches, bassPc = null) {
            if (!pitches || pitches.length === 0) return [];
            let finalPcs = [];
            if (bassPc !== null) {
                finalPcs.push(bassPc);
            }
            for (let pc of pitches) {
                if (bassPc !== null && pc === bassPc) continue;
                finalPcs.push(pc);
            }
            const TARGET_MIN = 55; // G3
            const TARGET_MAX = 67; // G4
            let bestMidis = null;
            let bestDev = Infinity;
            for (let baseOct = 3; baseOct <= 7; baseOct++) {
                let midis = [];
                let prevMidi = null;
                for (let i = 0; i < finalPcs.length; i++) {
                    let pc = finalPcs[i];
                    let oct;
                    if (prevMidi === null) {
                        oct = baseOct;
                    } else {
                        let candidateOct = Math.floor(prevMidi / 12);
                        let candidateMidi = candidateOct * 12 + pc;
                        if (candidateMidi > prevMidi) {
                            oct = candidateOct;
                        } else {
                            oct = candidateOct + 1;
                        }
                    }
                    let midi = oct * 12 + pc;
                    while (midi <= (prevMidi !== null ? prevMidi : -1)) {
                        oct++;
                        midi = oct * 12 + pc;
                    }
                    midis.push(midi);
                    prevMidi = midi;
                }
                let lowest = midis[0];
                if (lowest >= TARGET_MIN && lowest <= TARGET_MAX) {
                    bestMidis = midis;
                    break;
                }
                let dev = Math.abs(lowest - TARGET_MIN);
                if (dev < bestDev) {
                    bestDev = dev;
                    bestMidis = midis;
                }
            }
            return bestMidis || [];
        }

        // ---------- 解析进行字符串 ----------
        function parseProgression(progStr) {
            return progStr.split(',')
                .map(part => part.trim())
                .filter(part => part.length > 0)
                .map(name => parseChordName(name))
                .filter(res => res !== null);
        }

        // ---------- Web Audio 播放 ----------
        let audioCtx = null;
        let currentTimeouts = [];
        let activeOscillators = [];

        function getAudioContext() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        function stopAllSounds() {
            activeOscillators.forEach(osc => { try { osc.stop(); } catch(e) {} });
            activeOscillators = [];
            currentTimeouts.forEach(id => clearTimeout(id));
            currentTimeouts = [];
            if (audioCtx && audioCtx.state !== 'closed') audioCtx.suspend();
        }

        function computeNoteGain(midi) {
            const REF = 60, REF_GAIN = 0.12;
            let step = midi - REF;
            let db = step >= 0 ? -step : 0.5 * -step;  // 负半音时得到正 dB
            let linear = Math.pow(10, db / 20);
            return Math.min(2.0, Math.max(0.02, linear * REF_GAIN));
        }

        /*function playChord(midiNotes, durationSec = 1.2) {
            const ctx = getAudioContext();
            if (ctx.state === 'suspended') ctx.resume();
            // 可保留一个主 Gain（用来整体静音或将来加混响），但不是必须
            // 这里直接为每个音符创建独立的 gain 并连接 destination
            //const gainNode = ctx.createGain();
            //gainNode.gain.setValueAtTime(0.12, ctx.currentTime);
            //gainNode.connect(ctx.destination);
            midiNotes.forEach(midi => {
                const freq = 440 * Math.pow(2, (midi - 69) / 12);
                const osc = ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, ctx.currentTime);
                // --- 新增：每个音符自己的增益节点 ---
                const noteGain = ctx.createGain();
                const gainValue = computeNoteGain(midi);   // 计算补偿后的增益
                noteGain.gain.setValueAtTime(gainValue, ctx.currentTime);
                //osc.connect(gainNode);
                osc.connect(noteGain);
                noteGain.connect(ctx.destination);
                // ---------------------------------
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + durationSec);
                activeOscillators.push(osc);
                osc.onended = () => {
                    const idx = activeOscillators.indexOf(osc);
                    if (idx > -1) activeOscillators.splice(idx, 1);
                };
            });
        }*/
        function playChord(midiNotes, durationSec = 1.2) {
    const ctx = getAudioContext();
    if (ctx.state === 'suspended') ctx.resume();

    midiNotes.forEach(midi => {
        const baseFreq = 440 * Math.pow(2, (midi - 69) / 12);
        
        // --- 钢琴音色：主振荡器（三角波）---
        const osc = ctx.createOscillator();
        osc.type = 'triangle';                // 更丰富的泛音
        osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);

        // --- 钢琴音色：副振荡器（高八度，音量较低，增加明亮感）---
        const osc2 = ctx.createOscillator();
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime); // 高八度

        // --- 每个音符独立增益，并添加包络 ---
        const noteGain = ctx.createGain();
        const peakGain = computeNoteGain(midi);   // 仍保留原响度补偿

        // 包络：快速起音 → 指数衰减（模仿钢琴）
        const now = ctx.currentTime;
        noteGain.gain.cancelScheduledValues(now);
        noteGain.gain.setValueAtTime(0, now);                 // 从0开始
        noteGain.gain.linearRampToValueAtTime(peakGain, now + 0.005); // 5ms 起音
        noteGain.gain.exponentialRampToValueAtTime(0.001, now + 4); // 衰减到接近0

        // 连接：两个振荡器 → 同一个增益 → 输出
        osc.connect(noteGain);
        osc2.connect(noteGain);
        noteGain.connect(ctx.destination);

        // 启动与停止
        osc.start(now);
        osc2.start(now);
        osc.stop(now + durationSec);
        osc2.stop(now + durationSec);

        // 保持原有振荡器管理（用于紧急停止）
        activeOscillators.push(osc, osc2);
        osc.onended = () => {
            const idx = activeOscillators.indexOf(osc);
            if (idx > -1) activeOscillators.splice(idx, 1);
        };
        osc2.onended = () => {
            const idx = activeOscillators.indexOf(osc2);
            if (idx > -1) activeOscillators.splice(idx, 1);
        };
    });
}

        // ---------- 播放进行（每次都会重新解析编码表）----------
        function playProgression(progStr) {
            // 1. 读取编码表最新内容
            const tableTextarea = document.getElementById('chordTableInput');
            let tableText = tableTextarea.value.trim();
            if (tableText === '') tableText = DEFAULT_TABLE;
            chordPatterns = parseChordTable(tableText);

            // 2. 解析和弦进行
            const chords = parseProgression(progStr);
            if (chords.length === 0) return;

            // 3. 停止当前播放，准备新播放
            stopAllSounds();
            const ctx = getAudioContext();
            if (ctx.state === 'suspended') ctx.resume();

            let currentTime = ctx.currentTime;
            // 获取持续时间输入框的值，若无效则回退 1.2
            const durationInput = document.getElementById('durationInput');
            let DURATION = parseFloat(durationInput.value);
            if (isNaN(DURATION) || DURATION < 0.1) DURATION = 1.2;
            const INTERVAL = 0.1;
            let previewText = [];

            chords.forEach((chord, idx) => {
                let midis = pitchesToMidi(chord.pitches, chord.bassPc);
                if (!midis || midis.length === 0) return;
                const startTime = currentTime + idx * (DURATION + INTERVAL);
                const timeoutId = setTimeout(() => playChord(midis, DURATION), (startTime - ctx.currentTime) * 1000);
                currentTimeouts.push(timeoutId);
                previewText.push(midis.join(' '));
            });

            document.getElementById('preview').innerText = previewText.join('  |  ') || '—';
        }

        // ---------- 初始化UI事件 ----------
        window.onload = function() {
            const progInput = document.getElementById('chordProgInput');
            const playBtn = document.getElementById('playProgBtn');
            const stopBtn = document.getElementById('stopBtn');
            const editBtn = document.getElementById('editTableBtn');
            const tableTextarea = document.getElementById('chordTableInput');

            // 播放按钮：自动使用当前编码表内容
            playBtn.addEventListener('click', () => {
                playProgression(progInput.value);
            });

            // 停止按钮
            stopBtn.addEventListener('click', stopAllSounds);

            // 编辑按钮：仅切换显示/隐藏，不触发编码表更新
            editBtn.addEventListener('click', () => {
                if (tableTextarea.style.display === 'none') {
                    if (tableTextarea.value.trim() === '') {
                        tableTextarea.value = DEFAULT_TABLE;
                    }
                    tableTextarea.style.display = 'block';
                    editBtn.textContent = '✎ 编码表 ▲';
                } else {
                    tableTextarea.style.display = 'none';
                    editBtn.textContent = '✎ 编码表';
                }
            });

            // 页面关闭清理音频
            window.addEventListener('beforeunload', () => { if (audioCtx) audioCtx.close(); });

            // 初始播放一次，展示默认编码表效果
            setTimeout(() => {
                playProgression(progInput.value);
            }, 100);
        };
    </script>
</body>
</html>